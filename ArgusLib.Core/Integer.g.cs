#region Copyright and License
/*
This file is part of ArgusLib.
Copyright (C) 2017 Tobias Meyer
License: Microsoft Reciprocal License (MS-RL)
*/
#endregion

// AUTOGENERATED
// DO NOT MODIFY
namespace ArgusLib
{
	using System;
	using System.Reflection;

	static class Integer
	{
		#region byte

		static bool HasFlag(byte value, byte flag) { return (value & flag) == flag; }
		static byte RemoveFlag(byte value, byte flag) { return (byte)(value & (~flag)); }
		static byte SetFlag(byte value, byte flag) { return (byte)(value | flag); }
		static int ToInt32(byte value) { return (int)value; }
		static long ToInt64(byte value) { return (long)value; }
		static byte FromInt32_byte(int value) { return (byte)value; }
		static byte FromInt64_byte(long value) { return (byte)value; }

		#endregion

		#region sbyte

		static bool HasFlag(sbyte value, sbyte flag) { return (value & flag) == flag; }
		static sbyte RemoveFlag(sbyte value, sbyte flag) { return (sbyte)(value & (~flag)); }
		static sbyte SetFlag(sbyte value, sbyte flag) { return (sbyte)(value | flag); }
		static int ToInt32(sbyte value) { return (int)value; }
		static long ToInt64(sbyte value) { return (long)value; }
		static sbyte FromInt32_sbyte(int value) { return (sbyte)value; }
		static sbyte FromInt64_sbyte(long value) { return (sbyte)value; }

		#endregion

		#region ushort

		static bool HasFlag(ushort value, ushort flag) { return (value & flag) == flag; }
		static ushort RemoveFlag(ushort value, ushort flag) { return (ushort)(value & (~flag)); }
		static ushort SetFlag(ushort value, ushort flag) { return (ushort)(value | flag); }
		static int ToInt32(ushort value) { return (int)value; }
		static long ToInt64(ushort value) { return (long)value; }
		static ushort FromInt32_ushort(int value) { return (ushort)value; }
		static ushort FromInt64_ushort(long value) { return (ushort)value; }

		#endregion

		#region short

		static bool HasFlag(short value, short flag) { return (value & flag) == flag; }
		static short RemoveFlag(short value, short flag) { return (short)(value & (~flag)); }
		static short SetFlag(short value, short flag) { return (short)(value | flag); }
		static int ToInt32(short value) { return (int)value; }
		static long ToInt64(short value) { return (long)value; }
		static short FromInt32_short(int value) { return (short)value; }
		static short FromInt64_short(long value) { return (short)value; }

		#endregion

		#region uint

		static bool HasFlag(uint value, uint flag) { return (value & flag) == flag; }
		static uint RemoveFlag(uint value, uint flag) { return (uint)(value & (~flag)); }
		static uint SetFlag(uint value, uint flag) { return (uint)(value | flag); }
		static int ToInt32(uint value) { return (int)value; }
		static long ToInt64(uint value) { return (long)value; }
		static uint FromInt32_uint(int value) { return (uint)value; }
		static uint FromInt64_uint(long value) { return (uint)value; }

		#endregion

		#region int

		static bool HasFlag(int value, int flag) { return (value & flag) == flag; }
		static int RemoveFlag(int value, int flag) { return (int)(value & (~flag)); }
		static int SetFlag(int value, int flag) { return (int)(value | flag); }
		static int ToInt32(int value) { return (int)value; }
		static long ToInt64(int value) { return (long)value; }
		static int FromInt32_int(int value) { return (int)value; }
		static int FromInt64_int(long value) { return (int)value; }

		#endregion

		#region ulong

		static bool HasFlag(ulong value, ulong flag) { return (value & flag) == flag; }
		static ulong RemoveFlag(ulong value, ulong flag) { return (ulong)(value & (~flag)); }
		static ulong SetFlag(ulong value, ulong flag) { return (ulong)(value | flag); }
		static int ToInt32(ulong value) { return (int)value; }
		static long ToInt64(ulong value) { return (long)value; }
		static ulong FromInt32_ulong(int value) { return (ulong)value; }
		static ulong FromInt64_ulong(long value) { return (ulong)value; }

		#endregion

		#region long

		static bool HasFlag(long value, long flag) { return (value & flag) == flag; }
		static long RemoveFlag(long value, long flag) { return (long)(value & (~flag)); }
		static long SetFlag(long value, long flag) { return (long)(value | flag); }
		static int ToInt32(long value) { return (int)value; }
		static long ToInt64(long value) { return (long)value; }
		static long FromInt32_long(int value) { return (long)value; }
		static long FromInt64_long(long value) { return (long)value; }

		#endregion

		#region GetMethods

		static Type GetType<T>()
		{
			Type type = typeof(T);
			TypeInfo info = type.GetTypeInfo();
			if (info.IsPrimitive)
				return type;
			if (info.IsEnum)
				return Enum.GetUnderlyingType(type);
			throw new GenericTypeParameterNotSupportetException<T>(new NotSupportedException($"{nameof(T)} is expected to be a primitive integer type or an enum."));
		}

		internal static Func<T, T, bool> GetHasFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<byte, byte, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<sbyte, sbyte, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<ushort, ushort, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<short, short, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<uint, uint, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, int, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<ulong, ulong, bool>(HasFlag).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, long, bool>(HasFlag).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, bool>), null) as Func<T, T, bool>;
		}

		internal static Func<T, T, T> GetRemoveFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<byte, byte, byte>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<sbyte, sbyte, sbyte>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<ushort, ushort, ushort>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<short, short, short>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<uint, uint, uint>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, int, int>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<ulong, ulong, ulong>(RemoveFlag).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, long, long>(RemoveFlag).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, T>), null) as Func<T, T, T>;
		}

		internal static Func<T, T, T> GetSetFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<byte, byte, byte>(SetFlag).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<sbyte, sbyte, sbyte>(SetFlag).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<ushort, ushort, ushort>(SetFlag).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<short, short, short>(SetFlag).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<uint, uint, uint>(SetFlag).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, int, int>(SetFlag).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<ulong, ulong, ulong>(SetFlag).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, long, long>(SetFlag).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, T>), null) as Func<T, T, T>;
		}

		internal static Func<T, int> GetToInt32Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<byte, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<sbyte, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<ushort, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<short, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<uint, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<ulong, int>(ToInt32).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, int>(ToInt32).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, int>), null) as Func<T, int>;
		}

		internal static Func<T, long> GetToInt64Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<byte, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<sbyte, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<ushort, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<short, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<uint, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<ulong, long>(ToInt64).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, long>(ToInt64).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, long>), null) as Func<T, long>;
		}

		internal static Func<int, T> GetFromInt32Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<int, byte>(FromInt32_byte).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<int, sbyte>(FromInt32_sbyte).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<int, ushort>(FromInt32_ushort).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<int, short>(FromInt32_short).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<int, uint>(FromInt32_uint).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<int, int>(FromInt32_int).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<int, ulong>(FromInt32_ulong).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<int, long>(FromInt32_long).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<int, T>), null) as Func<int, T>;
		}

		internal static Func<long, T> GetFromInt64Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
			else if (type == typeof(byte))
				method = new Func<long, byte>(FromInt64_byte).GetMethodInfo();
			else if (type == typeof(sbyte))
				method = new Func<long, sbyte>(FromInt64_sbyte).GetMethodInfo();
			else if (type == typeof(ushort))
				method = new Func<long, ushort>(FromInt64_ushort).GetMethodInfo();
			else if (type == typeof(short))
				method = new Func<long, short>(FromInt64_short).GetMethodInfo();
			else if (type == typeof(uint))
				method = new Func<long, uint>(FromInt64_uint).GetMethodInfo();
			else if (type == typeof(int))
				method = new Func<long, int>(FromInt64_int).GetMethodInfo();
			else if (type == typeof(ulong))
				method = new Func<long, ulong>(FromInt64_ulong).GetMethodInfo();
			else if (type == typeof(long))
				method = new Func<long, long>(FromInt64_long).GetMethodInfo();
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<long, T>), null) as Func<long, T>;
		}

		#endregion
	}
}