<# /*
This file is part of ArgusLib
Copyright (C) 2017 Tobias Meyer
License: Microsoft Reciprocal License (MS-RL)
*/ #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
string[] Types = new string[] { "short", "ushort", "int", "uint", "long", "ulong", "float", "double", "decimal" };
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
#region Copyright and License
/*
This file is part of ArgusLib.
Copyright (C) 2017 Tobias Meyer
License: Microsoft Reciprocal License (MS-RL)
*/
#endregion

// AUTOGENERATED
// DO NOT MODIFY
namespace ArgusLib
{
	using System;
	using ArgusLib.Diagnostics.Tracing;

	public static partial class BitConverterEx
	{
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
		/// <summary>
		/// Writes the byte representation of <paramref name="val"/> to <paramref name="buffer"/>
		/// starting at index <paramref name="startIndex"/> and returns the number of bytes written.
		/// </summary>
		public static int GetBytes(<#=type#> val, byte[] buffer, int startIndex = 0)
		{
			if (buffer == null)
				throw Tracer.ThrowError(new ArgumentNullException(nameof(buffer)), typeof(BitConverterEx));
			if (startIndex < 0 || buffer.Length < startIndex + sizeof(<#=type#>))
				throw Tracer.ThrowError(new ArgumentOutOfRangeException(nameof(startIndex)), typeof(BitConverterEx));

			unsafe
			{
				byte* ptr = (byte*)&val;
				for (int i = 0; i < sizeof(<#=type#>); i++)
					buffer[startIndex + i] = ptr[i];
			}
			return sizeof(<#=type#>);
		}

<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
	}
}