<# /*
This file is part of ArgusLib
Copyright (C) 2017 Tobias Meyer
License: Microsoft Reciprocal License (MS-RL)
*/ #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
string[] Types = new string[] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long" };
const string hasFlag = "HasFlag";
const string removeFlag = "RemoveFlag";
const string setFlag = "SetFlag";
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
#region Copyright and License
/*
This file is part of ArgusLib.
Copyright (C) 2017 Tobias Meyer
License: Microsoft Reciprocal License (MS-RL)
*/
#endregion

// AUTOGENERATED
// DO NOT MODIFY
namespace ArgusLib
{
	using System;
	using System.Reflection;

	static class Integer
	{
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
		#region <#= type #>

		static bool <#= hasFlag #>(<#= type #> value, <#= type #> flag) { return (value & flag) == flag; }
		static <#= type #> <#= removeFlag #>(<#= type #> value, <#= type #> flag) { return (<#= type #>)(value & (~flag)); }
		static <#= type #> <#= setFlag #>(<#= type #> value, <#= type #> flag) { return (<#= type #>)(value | flag); }
		static int ToInt32(<#= type #> value) { return (int)value; }
		static long ToInt64(<#= type #> value) { return (long)value; }
		static <#= type #> FromInt32_<#= type #>(int value) { return (<#= type #>)value; }
		static <#= type #> FromInt64_<#= type #>(long value) { return (<#= type #>)value; }

		#endregion

<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
		#region GetMethods

		static Type GetType<T>()
		{
			Type type = typeof(T);
			TypeInfo info = type.GetTypeInfo();
			if (info.IsPrimitive)
				return type;
			if (info.IsEnum)
				return Enum.GetUnderlyingType(type);
			throw new GenericTypeParameterNotSupportetException<T>(new NotSupportedException($"{nameof(T)} is expected to be a primitive integer type or an enum."));
		}

		internal static Func<T, T, bool> GetHasFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<<#= type #>, <#= type #>, bool>(<#= hasFlag #>).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, bool>), null) as Func<T, T, bool>;
		}

		internal static Func<T, T, T> GetRemoveFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<<#= type #>, <#= type #>, <#= type #>>(<#= removeFlag #>).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, T>), null) as Func<T, T, T>;
		}

		internal static Func<T, T, T> GetSetFlagMethod<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<<#= type #>, <#= type #>, <#= type #>>(<#= setFlag #>).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, T, T>), null) as Func<T, T, T>;
		}

		internal static Func<T, int> GetToInt32Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<<#= type #>, int>(ToInt32).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, int>), null) as Func<T, int>;
		}

		internal static Func<T, long> GetToInt64Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<<#= type #>, long>(ToInt64).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<T, long>), null) as Func<T, long>;
		}

		internal static Func<int, T> GetFromInt32Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<int, <#= type #>>(FromInt32_<#= type #>).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<int, T>), null) as Func<int, T>;
		}

		internal static Func<long, T> GetFromInt64Method<T>()
		{
			Type type = GetType<T>();
			MethodInfo method;
			if (false)
				{ }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
foreach (string type in Types)
{
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else if (type == typeof(<#= type #>))
				method = new Func<long, <#= type #>>(FromInt64_<#= type #>).GetMethodInfo();
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
}
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
			else
				throw new GenericTypeParameterNotSupportetException<T>();
			return method.CreateDelegate(typeof(Func<long, T>), null) as Func<long, T>;
		}

		#endregion
	}
}